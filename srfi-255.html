<!DOCTYPE html>
<html lang="en">
  <!--
      SPDX-FileCopyrightText: Taylor Campbell, John Cowan, Wolfgang Corcoran-Mathe, Marc Nieper-Wißkirchen
      SPDX-License-Identifier: MIT
    -->
  <head>
    <meta charset="utf-8">
    <title>SRFI 255: Restarting conditions</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <style>
      <!--
      /* Names of Scheme types: boolean, pair, etc. */
      span.type-meta { font-style: italic }

      dt {
          font-style: italic;
          margin-top: 0.5em;
          clear: both
      }

      dt.tag-name {
          font-family: monospace;
          font-style: normal
      }

      /* Variables in syntax forms. */
      var.syn { font-style: normal; }
      var.syn:before { content: "\27E8"; }
      var.syn:after  { content: "\27E9"; }

      pre.example { margin-left: 2em; }
      -->
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1"></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo" /></a>255: Restarting conditions</h1>

<p>Wolfgang Corcoran-Mathe (co-author and revised implementation), and
  Marc Nieper-Wißkirchen (co-author)</p>

<h2 id="status">Status</h2>

    <p>This SRFI is currently in <em>withdrawn</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+255+at+srfi+dotschemers+dot+org">srfi-255@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-255/">archive</a>.</p>
    <ul>
      <li>Received: 2024-09-13
        <p>This SRFI was forked from SRFI 249 on that date.</p></li>
      <li>60-day deadline: 2024-11-12</li>
      <li>Draft #1 published: 2024-09-13</li>
    </ul>

<h2 id="table-of-contents">Table of Contents</h2>

<ol>
  <li><a href="#abstract">Abstract</a></li>
  <li><a href="#issues">Issues</a></li>
  <li><a href="#rationale">Rationale</a></li>
  <li><a href="#specification">Specification</a>
    <ol>
      <li><a href="#procedures">Procedures</a></li>
      <li><a href="#parameter-objects">Parameter objects</a></li>
      <li><a href="#syntax">Syntax</a></li>
    </ol>
  </li>
  <li><a href="#implementation">Implementation</a></li>
  <li><a href="#acknowledgements">Acknowledgements</a></li>
  <li><a href="#copyright">Copyright</a></li>
</ol>

<h2 id="abstract">Abstract</h2>

<p>When an exceptional situation is encountered by a program, it
usually creates a condition object describing the situation and then
passes control to an exception handler. The
signaler and handler are two different parts of a system, between which
there is a barrier of abstraction. In order to recover gracefully and
flexibly from exceptional situations, however, the signaler can provide
multiple ways by which the handler can restart the computation, some of
which may require extra input. Often, the decision of which method of
recovery to choose is left up to a human user, who may be prompted for
the input needed to recover. This SRFI proposes a mechanism
called <dfn>restarters</dfn> which uses a new type of condition object
and an associated exception handler to encapsulate the information
necessary to restart a computation. We also
describe the behavior and interface of <dfn>interactor</dfn> procedures,
which implement interactive restarts.</p>

<h2 id="issues">Issues</h2>

<p>Using the name “with-restarters” for a macro violates Scheme
conventions.</p>

<p>Should we provide <code>make-restarter</code>? Hand-crafted
restarters aren’t guaranteed to honor the “no return” contract.</p>

<p>Should <code>with-restarters</code> provide a way to
control which kinds of conditions can be restarted? Currently,
<code>with-restarters</code> is specified to restart any exception
that occurs.</p>

<h2 id="rationale">Rationale</h2>

<p>An effective and flexible system for gracefully handling and
recovering from exceptional situations is a necessity for any large
software system. While the continuable exceptions and <code>guard</code>
form described in the <cite>R6RS</cite> and <cite>R7RS</cite> reports
provide a basic kind of recovery system, they do not make it
convenient for a signaling process to offer a choice of recovery
routes to the handler. This SRFI attempts to make up for this
deficiency by extending the handler-condition system with the forms
and mechanisms needed for convenient recovery.</p>

<p>One important feature for a restart system to provide is
interactivity. Though purely programmatic condition recovery is useful,
it is well-acknowledged by the designers and users of Common Lisp’s
condition system that the ability to <em>interactively</em> choose a
method of recovery for a condition is useful.  This ability, built-in to the Common
Lisp language, is one of the primary reasons for the power of Common
Lisp development and debugging environments. In
this SRFI, the interactivity is provided by an <dfn>interactor
procedure</dfn> that by default is provided by the implementation, but
can be overridden by the user.</p>

<h3>SRFI 249</h3>

<p>An earlier attempt at a restart system was made by the authors of
<a href="https://srfi.schemers.org/srfi-249">SRFI 249</a>, on which
the current SRFI was originally based. The SRFI 249 system is very
simple--indeed, it is less a restart system than a
“build-your-own-restart-system” kit, since it requires careful
programming to create correct restarters with the low-level tools
that SRFI 249 provides. In contrast, SRFI 255 provides a high-level
interface that automatically handles the messy control details.
(Restarters can still be constructed “by hand”, if need be.)</p>

<p>Since the bulk of the SRFI 249 system
also predates the exception systems of modern Scheme, it also
duplicates the functionality of Scheme’s exception handlers by
introducing a “restarter stack”. This stack, as a SRFI 39 / R7RS
parameter object, is made part of the dynamic context of a Scheme
program. Since we use the native exception system to install and
manage restarters, there is no need for this complication.</p>

<!-- Specification section -->

<h2 id="specification">Specification</h2>

<p>A <dfn>restarter</dfn> is a condition object (see the R6RS standard
libraries document, Section 7.2) of type <code>&amp;restarter</code>.
It has four fields:</p>

<dl>
  <dt>tag</dt>
  <dd>A symbol describing this restarter.</dd>

  <dt>description</dt>
  <dd>A string that describes the method of
  recovery and the values, if any, needed for recovery.</dd>

  <dt>who</dt>
  <dd>A string or symbol identifying the entity reporting the
  exception that triggered the raising of the restarter
  condition.</dd>

  <dt>formals</dt>
  <dd>A symbol, list, or improper formals list as described in Section
  4.1.4 of the R7RS, describing the arguments expected by the
  restarter’s <var>invoker</var>.</dd>

  <dt>invoker</dt>
  <dd>A procedure that actually performs the recovery. It must not
  return. The number of arguments it expects is given by
  <var>formals</var>.</dd>
</dl>

<p>Restarters are usually <dfn>ambient</dfn>; they are constructed
on the fly and <dfn>established</dfn>: an exception handler is
installed that makes all currently-established restarters available
whenever a exception is raised.</p>

<p>When a restarter is raised in response to an exception (called the
<dfn>triggering exception</dfn> in this document), it should be a
composite condition (see Section 7.2.1 of the R6RS) including the
object raised by the triggering exception as one of its components.</p>

<!-- Procedures section -->

<h3 id="procedures">Procedures</h3>

<p><code>(make-restarter</code> <var>tag</var> <var>description</var>
<var>who</var> <var>invoker</var><code>)</code> →
<span class="type-meta">restarter</span></p>

<p>Returns a restarter with the specified fields. The arguments of
<code>make-restarter</code> must conform to the above specification
of restarter fields. In particular, the <var>invoker</var> procedure
must not return to its caller.</p>

<p><code>(restarter?</code> <var>obj</var><code>)</code> →
<span class="type-meta">boolean</span></p>

<p>Returns <code>#t</code> if <var>obj</var> is a restarter and
<code>#f</code> otherwise.</p>

<p><code>(restarter-tag</code> <var>restarter</var><code>)</code> →
<span class="type-meta">symbol</span><br>

<code>(restarter-description</code> <var>restarter</var><code>)</code> →
<span class="type-meta">string</span><br>

<code>(restarter-who</code> <var>restarter</var><code>)</code> →
<span class="type-meta">symbol-or-string</span><br>

<code>(restarter-formals</code> <var>restarter</var><code>)</code> →
<span class="type-meta">pair-or-symbol</span></p>

<p>Returns the tag / description / who / formals of <var>restarter</var>.
The effect of mutating the values returned by these procedures is
undefined.</p>

<p><code>(restart</code> <var>restarter</var> <var>arg</var>
…<code>)</code> → does not return</p>

<p>Invokes the invoker procedure of <var>restarter</var> on the
<var>args</var>.</p>

<p>If <var>restarter</var>’s invoker returns, then
the result is undefined.</p>

<p><code>(with-abort-restarter</code> <var>thunk</var><code>)</code></p>

<p>Establishes a restarter with tag <code>abort</code> for the dynamic
extent of <var>thunk</var> (as determined by <code>dynamic-wind</code>).
The <code>abort</code> restarter accepts zero arguments. When invoked,
execution resumes with the continuation and dynamic environment of the
<code>with-abort-restarter</code> form.</p>

<!-- Interactors section -->

<h4 id="interactors">Interactors</h4>

<p>An <dfn>interactor</dfn> is a procedure of one argument, a list of
restarters. The interactor presents the tags, formals, and
descriptions of those restarters to the user, who then
picks a tag and provides a list of expressions. Those expressions are
then evaluated in the value of <code>(interaction-environment)</code>,
and <code>restart</code>
is applied to the chosen restarter and the user-provided values.</p>

<p>If an interactor returns, a non-continuable exception [TODO: of what
type?] is raised.</p>

<p><code>(with-interactor</code> <var>interactor</var>
<var>thunk</var><code>)</code></p>

<p>Returns the results of invoking <var>thunk</var>. A new current
exception handler is installed for the dynamic extent (as determined by
<code>dynamic-wind</code>) of the invocation of <var>thunk</var>. If a
restartable condition is raised in this extent, the handler invokes
<var>interactor</var> on the list of available restarters provided by
that condition.</p>

<p><code>(with-current-interactor</code>
<var>thunk</var><code>)</code></p>

<p>Equivalent to</p>

<pre class="example"><code>(with-interactor (current-interactor) <var>thunk</var>)</code></pre>

<!-- Parameters section -->

<h3 id="parameter-objects">Parameter objects</h3>

<p><code>current-interactor</code></p>

<p>A SRFI 39 / R7RS parameter object whose value is an interactor
procedure.</p>

<!-- Syntax section -->

<h3 id="syntax">Syntax</h3>

<p><code>(with-restarters</code> <var class="syn">restarter-clauses</var>
<var class="syn">body</var><code>)</code></p>

<p><code>(with-restarters</code> <var class="syn">who</var>
<var class="syn">restarter-clauses</var>
<var class="syn">body</var><code>)</code></p>

<h5>Syntax:</h5>

<p><var class="syn">restarter-clauses</var> takes one of two forms,
either</p>

<pre><code>(((</code><var class="syn">tag</var> <code>.</code> <var class="syn">formals</var><code>)</code>
  <var class="syn">description</var>
  <var class="syn">expression1</var> <var class="syn">expression2</var> …<code>) …)</code></pre>

<p>or</p>

<pre><code>(</code><var class="syn">condition-var</var>
 <code>((</code><var class="syn">tag</var> <code>.</code> <var class="syn">formals</var><code>)</code>
  <var class="syn">description</var>
  <var class="syn">expression1</var> <var class="syn">expression2</var> …<code>) …)</code></pre>

<p><var class="syn">who</var> should be an identifier or string.
<var class="syn">condition-var</var> and <var class="syn">tag</var>
tag are identifiers. <var class="syn">formals</var> is a formals list
as specified in Section 4.1.4 of the R7RS.
<var class="syn">description</var> is a string.</p>

<h5>Semantics:</h5>

<p>Installs a new exception handler for the dynamic extent (as
determined by <code>dynamic-wind</code>) of the invocation of
<var class="syn">body</var>. If an exception occurs, this handler
constructs a restarter condition from the raised condition and from
restarters constructed from the <var class="syn">restarter-clauses</var>,
and raises it with <code>raise-continuable</code>. If
<var class="syn">condition-var</var> is provided, then the condition
object raised by the original triggering exception is bound to it in
the environment of this handler.</p>

<p>The who field of each restarter constructed from
<var class="syn">restarter-clauses</var> is filled by
<var class="syn">who</var>, or <code>#f</code> if
<var class="syn">who</var> was omitted. Each invoker is constructed
from the <var class="syn">expressions</var>; when it is invoked, the
values of the final <var class="syn">expression</var> are delivered
to the continuation of the <code>with-restarters</code> form.</p>

<h4>Restartable procedure syntax</h4>

<p>A <code>restartable</code> form wraps a procedure in code allowing
the procedure to be re-invoked on new arguments if an assertion
violation occurs. It takes one of the following forms:</p>

<ul>
  <li><p><code>(restartable define</code> <var class="syn">variable</var>
  <var class="syn">expr</var><code>)</code></p></li>

  <li><p><code>(restartable define (</code><var class="syn">variable</var>
  <var class="syn">formals</var><code>)</code>
  <var class="syn">expr</var><code>)</code></p>

  <p><var class="syn">expr</var> must evaluate to a procedure. The
  <code>restartable</code> form defines <var class="syn">variable</var>,
  binding it to a new procedure. A restarter is established for the
  dynamic extent of this procedure's invocation. If an assertion
  violation (an exception raising a condition having type
  <code>&assertion</code> (see R6RS §7.3)) occurs during invocation,
  the restarter accepts new formals and re-invokes the procedure on
  these arguments. The <code>who</code> and <code>formals</code> fields
  of the restarter should contain <var class="syn">variable</var> and
  <var class="syn">formals</var> (if provided) respectively.</p></li>

  <li><p><code>(restartable</code> <var class="syn">who</var>
  <var class="syn">expr</var><code>)</code></p></li>

  <li><p><code>(restartable</code>
  <var class="syn">expr</var><code>)</code></p>

  <p>Evaluates to a procedure with the restartable-invocation
  semantics described above. <var class="syn">who</var> gives the
  <code>who</code> field for the restarter; it must be a symbol or
  string</p></li>
</ul>


<!-- Implementation section -->

<h2 id="implementation">Implementation</h2>
<p>The implementation is available at
<a href="https://github.com/scheme-requests-for-implementation/srfi-255">Github</a>.

<h2 id="acknowledgements">Acknowledgements</h2>

<p>This SRFI is based on
<a href="https://mumble.net/~campbell/proposals/restart.text">a
proposal</a> by Taylor Campbell.</p>

<p>John Cowan was author
of <a href="https://srfi.schemers.org/srfi-249/">SRFI 249</a>, from
which this SRFI is derived.</p>

<p>Arvydas Silanskas wrote the initial implementation of SRFI 249.</p>

<p>Wolfgang Corcoran-Mathe wrote the revised implementation of SRFI 249.</p>

<h2 id="copyright">Copyright</h2>
<p>&copy; 2023 Taylor Campbell, John Cowan, Wolfgang
Corcoran-Mathe), Arvydas Silanskas.</p>

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:</p>

<p>
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.</p>
<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.</p>

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
